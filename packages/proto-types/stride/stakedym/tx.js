"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.3
// source: stride/stakedym/tx.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MsgSetOperatorAddressResponse = exports.MsgSetOperatorAddress = exports.MsgOverwriteRedemptionRecordResponse = exports.MsgOverwriteRedemptionRecord = exports.MsgOverwriteUnbondingRecordResponse = exports.MsgOverwriteUnbondingRecord = exports.MsgOverwriteDelegationRecordResponse = exports.MsgOverwriteDelegationRecord = exports.MsgRefreshRedemptionRateResponse = exports.MsgRefreshRedemptionRate = exports.MsgResumeHostZoneResponse = exports.MsgResumeHostZone = exports.MsgUpdateInnerRedemptionRateBoundsResponse = exports.MsgUpdateInnerRedemptionRateBounds = exports.MsgAdjustDelegatedBalanceResponse = exports.MsgAdjustDelegatedBalance = exports.MsgConfirmUnbondedTokenSweepResponse = exports.MsgConfirmUnbondedTokenSweep = exports.MsgConfirmUndelegationResponse = exports.MsgConfirmUndelegation = exports.MsgConfirmDelegationResponse = exports.MsgConfirmDelegation = exports.MsgRedeemStakeResponse = exports.MsgRedeemStake = exports.MsgLiquidStakeResponse = exports.MsgLiquidStake = exports.overwritableRecordTypeToJSON = exports.overwritableRecordTypeFromJSON = exports.OverwritableRecordType = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const coin_1 = require("../../cosmos/base/v1beta1/coin");
const stakedym_1 = require("./stakedym");
exports.protobufPackage = "stride.stakedym";
var OverwritableRecordType;
(function (OverwritableRecordType) {
    OverwritableRecordType[OverwritableRecordType["RECORD_TYPE_DELEGATION"] = 0] = "RECORD_TYPE_DELEGATION";
    OverwritableRecordType[OverwritableRecordType["RECORD_TYPE_UNBONDING"] = 1] = "RECORD_TYPE_UNBONDING";
    OverwritableRecordType[OverwritableRecordType["RECORD_TYPE_REDEMPTION"] = 2] = "RECORD_TYPE_REDEMPTION";
    OverwritableRecordType[OverwritableRecordType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(OverwritableRecordType = exports.OverwritableRecordType || (exports.OverwritableRecordType = {}));
function overwritableRecordTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "RECORD_TYPE_DELEGATION":
            return OverwritableRecordType.RECORD_TYPE_DELEGATION;
        case 1:
        case "RECORD_TYPE_UNBONDING":
            return OverwritableRecordType.RECORD_TYPE_UNBONDING;
        case 2:
        case "RECORD_TYPE_REDEMPTION":
            return OverwritableRecordType.RECORD_TYPE_REDEMPTION;
        case -1:
        case "UNRECOGNIZED":
        default:
            return OverwritableRecordType.UNRECOGNIZED;
    }
}
exports.overwritableRecordTypeFromJSON = overwritableRecordTypeFromJSON;
function overwritableRecordTypeToJSON(object) {
    switch (object) {
        case OverwritableRecordType.RECORD_TYPE_DELEGATION:
            return "RECORD_TYPE_DELEGATION";
        case OverwritableRecordType.RECORD_TYPE_UNBONDING:
            return "RECORD_TYPE_UNBONDING";
        case OverwritableRecordType.RECORD_TYPE_REDEMPTION:
            return "RECORD_TYPE_REDEMPTION";
        case OverwritableRecordType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
exports.overwritableRecordTypeToJSON = overwritableRecordTypeToJSON;
function createBaseMsgLiquidStake() {
    return { staker: "", nativeAmount: "" };
}
exports.MsgLiquidStake = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.staker !== "") {
            writer.uint32(10).string(message.staker);
        }
        if (message.nativeAmount !== "") {
            writer.uint32(18).string(message.nativeAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStake();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.staker = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.nativeAmount = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            staker: isSet(object.staker) ? globalThis.String(object.staker) : "",
            nativeAmount: isSet(object.nativeAmount) ? globalThis.String(object.nativeAmount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.staker !== "") {
            obj.staker = message.staker;
        }
        if (message.nativeAmount !== "") {
            obj.nativeAmount = message.nativeAmount;
        }
        return obj;
    },
    create(base) {
        return exports.MsgLiquidStake.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgLiquidStake();
        message.staker = (_a = object.staker) !== null && _a !== void 0 ? _a : "";
        message.nativeAmount = (_b = object.nativeAmount) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgLiquidStakeResponse() {
    return { stToken: undefined };
}
exports.MsgLiquidStakeResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.stToken !== undefined) {
            coin_1.Coin.encode(message.stToken, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgLiquidStakeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.stToken = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { stToken: isSet(object.stToken) ? coin_1.Coin.fromJSON(object.stToken) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.stToken !== undefined) {
            obj.stToken = coin_1.Coin.toJSON(message.stToken);
        }
        return obj;
    },
    create(base) {
        return exports.MsgLiquidStakeResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseMsgLiquidStakeResponse();
        message.stToken = (object.stToken !== undefined && object.stToken !== null)
            ? coin_1.Coin.fromPartial(object.stToken)
            : undefined;
        return message;
    },
};
function createBaseMsgRedeemStake() {
    return { redeemer: "", stTokenAmount: "" };
}
exports.MsgRedeemStake = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.redeemer !== "") {
            writer.uint32(10).string(message.redeemer);
        }
        if (message.stTokenAmount !== "") {
            writer.uint32(18).string(message.stTokenAmount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStake();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.redeemer = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.stTokenAmount = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            redeemer: isSet(object.redeemer) ? globalThis.String(object.redeemer) : "",
            stTokenAmount: isSet(object.stTokenAmount) ? globalThis.String(object.stTokenAmount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.redeemer !== "") {
            obj.redeemer = message.redeemer;
        }
        if (message.stTokenAmount !== "") {
            obj.stTokenAmount = message.stTokenAmount;
        }
        return obj;
    },
    create(base) {
        return exports.MsgRedeemStake.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgRedeemStake();
        message.redeemer = (_a = object.redeemer) !== null && _a !== void 0 ? _a : "";
        message.stTokenAmount = (_b = object.stTokenAmount) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgRedeemStakeResponse() {
    return { nativeToken: undefined };
}
exports.MsgRedeemStakeResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nativeToken !== undefined) {
            coin_1.Coin.encode(message.nativeToken, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRedeemStakeResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nativeToken = coin_1.Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { nativeToken: isSet(object.nativeToken) ? coin_1.Coin.fromJSON(object.nativeToken) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.nativeToken !== undefined) {
            obj.nativeToken = coin_1.Coin.toJSON(message.nativeToken);
        }
        return obj;
    },
    create(base) {
        return exports.MsgRedeemStakeResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseMsgRedeemStakeResponse();
        message.nativeToken = (object.nativeToken !== undefined && object.nativeToken !== null)
            ? coin_1.Coin.fromPartial(object.nativeToken)
            : undefined;
        return message;
    },
};
function createBaseMsgConfirmDelegation() {
    return { operator: "", recordId: "0", txHash: "" };
}
exports.MsgConfirmDelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
            writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
            writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
            writer.uint32(26).string(message.txHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmDelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.operator = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.recordId = longToString(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.txHash = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
            recordId: isSet(object.recordId) ? globalThis.String(object.recordId) : "0",
            txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.operator !== "") {
            obj.operator = message.operator;
        }
        if (message.recordId !== "0") {
            obj.recordId = message.recordId;
        }
        if (message.txHash !== "") {
            obj.txHash = message.txHash;
        }
        return obj;
    },
    create(base) {
        return exports.MsgConfirmDelegation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgConfirmDelegation();
        message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgConfirmDelegationResponse() {
    return {};
}
exports.MsgConfirmDelegationResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmDelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgConfirmDelegationResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgConfirmDelegationResponse();
        return message;
    },
};
function createBaseMsgConfirmUndelegation() {
    return { operator: "", recordId: "0", txHash: "" };
}
exports.MsgConfirmUndelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
            writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
            writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
            writer.uint32(26).string(message.txHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUndelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.operator = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.recordId = longToString(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.txHash = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
            recordId: isSet(object.recordId) ? globalThis.String(object.recordId) : "0",
            txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.operator !== "") {
            obj.operator = message.operator;
        }
        if (message.recordId !== "0") {
            obj.recordId = message.recordId;
        }
        if (message.txHash !== "") {
            obj.txHash = message.txHash;
        }
        return obj;
    },
    create(base) {
        return exports.MsgConfirmUndelegation.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgConfirmUndelegation();
        message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgConfirmUndelegationResponse() {
    return {};
}
exports.MsgConfirmUndelegationResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUndelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgConfirmUndelegationResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgConfirmUndelegationResponse();
        return message;
    },
};
function createBaseMsgConfirmUnbondedTokenSweep() {
    return { operator: "", recordId: "0", txHash: "" };
}
exports.MsgConfirmUnbondedTokenSweep = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
            writer.uint32(10).string(message.operator);
        }
        if (message.recordId !== "0") {
            writer.uint32(16).uint64(message.recordId);
        }
        if (message.txHash !== "") {
            writer.uint32(26).string(message.txHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUnbondedTokenSweep();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.operator = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.recordId = longToString(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.txHash = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
            recordId: isSet(object.recordId) ? globalThis.String(object.recordId) : "0",
            txHash: isSet(object.txHash) ? globalThis.String(object.txHash) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.operator !== "") {
            obj.operator = message.operator;
        }
        if (message.recordId !== "0") {
            obj.recordId = message.recordId;
        }
        if (message.txHash !== "") {
            obj.txHash = message.txHash;
        }
        return obj;
    },
    create(base) {
        return exports.MsgConfirmUnbondedTokenSweep.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgConfirmUnbondedTokenSweep();
        message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : "";
        message.recordId = (_b = object.recordId) !== null && _b !== void 0 ? _b : "0";
        message.txHash = (_c = object.txHash) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgConfirmUnbondedTokenSweepResponse() {
    return {};
}
exports.MsgConfirmUnbondedTokenSweepResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgConfirmUnbondedTokenSweepResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgConfirmUnbondedTokenSweepResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgConfirmUnbondedTokenSweepResponse();
        return message;
    },
};
function createBaseMsgAdjustDelegatedBalance() {
    return { operator: "", delegationOffset: "", validatorAddress: "" };
}
exports.MsgAdjustDelegatedBalance = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.operator !== "") {
            writer.uint32(10).string(message.operator);
        }
        if (message.delegationOffset !== "") {
            writer.uint32(18).string(message.delegationOffset);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(26).string(message.validatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAdjustDelegatedBalance();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.operator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.delegationOffset = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
            delegationOffset: isSet(object.delegationOffset) ? globalThis.String(object.delegationOffset) : "",
            validatorAddress: isSet(object.validatorAddress) ? globalThis.String(object.validatorAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.operator !== "") {
            obj.operator = message.operator;
        }
        if (message.delegationOffset !== "") {
            obj.delegationOffset = message.delegationOffset;
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        return obj;
    },
    create(base) {
        return exports.MsgAdjustDelegatedBalance.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgAdjustDelegatedBalance();
        message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : "";
        message.delegationOffset = (_b = object.delegationOffset) !== null && _b !== void 0 ? _b : "";
        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgAdjustDelegatedBalanceResponse() {
    return {};
}
exports.MsgAdjustDelegatedBalanceResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAdjustDelegatedBalanceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgAdjustDelegatedBalanceResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgAdjustDelegatedBalanceResponse();
        return message;
    },
};
function createBaseMsgUpdateInnerRedemptionRateBounds() {
    return { creator: "", minInnerRedemptionRate: "", maxInnerRedemptionRate: "" };
}
exports.MsgUpdateInnerRedemptionRateBounds = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.minInnerRedemptionRate !== "") {
            writer.uint32(18).string(message.minInnerRedemptionRate);
        }
        if (message.maxInnerRedemptionRate !== "") {
            writer.uint32(26).string(message.maxInnerRedemptionRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.minInnerRedemptionRate = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.maxInnerRedemptionRate = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            minInnerRedemptionRate: isSet(object.minInnerRedemptionRate)
                ? globalThis.String(object.minInnerRedemptionRate)
                : "",
            maxInnerRedemptionRate: isSet(object.maxInnerRedemptionRate)
                ? globalThis.String(object.maxInnerRedemptionRate)
                : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.minInnerRedemptionRate !== "") {
            obj.minInnerRedemptionRate = message.minInnerRedemptionRate;
        }
        if (message.maxInnerRedemptionRate !== "") {
            obj.maxInnerRedemptionRate = message.maxInnerRedemptionRate;
        }
        return obj;
    },
    create(base) {
        return exports.MsgUpdateInnerRedemptionRateBounds.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMsgUpdateInnerRedemptionRateBounds();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.minInnerRedemptionRate = (_b = object.minInnerRedemptionRate) !== null && _b !== void 0 ? _b : "";
        message.maxInnerRedemptionRate = (_c = object.maxInnerRedemptionRate) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseMsgUpdateInnerRedemptionRateBoundsResponse() {
    return {};
}
exports.MsgUpdateInnerRedemptionRateBoundsResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgUpdateInnerRedemptionRateBoundsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateInnerRedemptionRateBoundsResponse();
        return message;
    },
};
function createBaseMsgResumeHostZone() {
    return { creator: "" };
}
exports.MsgResumeHostZone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgResumeHostZone();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { creator: isSet(object.creator) ? globalThis.String(object.creator) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        return obj;
    },
    create(base) {
        return exports.MsgResumeHostZone.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgResumeHostZone();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseMsgResumeHostZoneResponse() {
    return {};
}
exports.MsgResumeHostZoneResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgResumeHostZoneResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgResumeHostZoneResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgResumeHostZoneResponse();
        return message;
    },
};
function createBaseMsgRefreshRedemptionRate() {
    return { creator: "" };
}
exports.MsgRefreshRedemptionRate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRefreshRedemptionRate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { creator: isSet(object.creator) ? globalThis.String(object.creator) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        return obj;
    },
    create(base) {
        return exports.MsgRefreshRedemptionRate.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgRefreshRedemptionRate();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseMsgRefreshRedemptionRateResponse() {
    return {};
}
exports.MsgRefreshRedemptionRateResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRefreshRedemptionRateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgRefreshRedemptionRateResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgRefreshRedemptionRateResponse();
        return message;
    },
};
function createBaseMsgOverwriteDelegationRecord() {
    return { creator: "", delegationRecord: undefined };
}
exports.MsgOverwriteDelegationRecord = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.delegationRecord !== undefined) {
            stakedym_1.DelegationRecord.encode(message.delegationRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteDelegationRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.delegationRecord = stakedym_1.DelegationRecord.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            delegationRecord: isSet(object.delegationRecord) ? stakedym_1.DelegationRecord.fromJSON(object.delegationRecord) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.delegationRecord !== undefined) {
            obj.delegationRecord = stakedym_1.DelegationRecord.toJSON(message.delegationRecord);
        }
        return obj;
    },
    create(base) {
        return exports.MsgOverwriteDelegationRecord.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgOverwriteDelegationRecord();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.delegationRecord = (object.delegationRecord !== undefined && object.delegationRecord !== null)
            ? stakedym_1.DelegationRecord.fromPartial(object.delegationRecord)
            : undefined;
        return message;
    },
};
function createBaseMsgOverwriteDelegationRecordResponse() {
    return {};
}
exports.MsgOverwriteDelegationRecordResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteDelegationRecordResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgOverwriteDelegationRecordResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgOverwriteDelegationRecordResponse();
        return message;
    },
};
function createBaseMsgOverwriteUnbondingRecord() {
    return { creator: "", unbondingRecord: undefined };
}
exports.MsgOverwriteUnbondingRecord = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.unbondingRecord !== undefined) {
            stakedym_1.UnbondingRecord.encode(message.unbondingRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteUnbondingRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.unbondingRecord = stakedym_1.UnbondingRecord.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            unbondingRecord: isSet(object.unbondingRecord) ? stakedym_1.UnbondingRecord.fromJSON(object.unbondingRecord) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.unbondingRecord !== undefined) {
            obj.unbondingRecord = stakedym_1.UnbondingRecord.toJSON(message.unbondingRecord);
        }
        return obj;
    },
    create(base) {
        return exports.MsgOverwriteUnbondingRecord.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgOverwriteUnbondingRecord();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.unbondingRecord = (object.unbondingRecord !== undefined && object.unbondingRecord !== null)
            ? stakedym_1.UnbondingRecord.fromPartial(object.unbondingRecord)
            : undefined;
        return message;
    },
};
function createBaseMsgOverwriteUnbondingRecordResponse() {
    return {};
}
exports.MsgOverwriteUnbondingRecordResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteUnbondingRecordResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgOverwriteUnbondingRecordResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgOverwriteUnbondingRecordResponse();
        return message;
    },
};
function createBaseMsgOverwriteRedemptionRecord() {
    return { creator: "", redemptionRecord: undefined };
}
exports.MsgOverwriteRedemptionRecord = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.redemptionRecord !== undefined) {
            stakedym_1.RedemptionRecord.encode(message.redemptionRecord, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteRedemptionRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.redemptionRecord = stakedym_1.RedemptionRecord.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
            redemptionRecord: isSet(object.redemptionRecord) ? stakedym_1.RedemptionRecord.fromJSON(object.redemptionRecord) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.redemptionRecord !== undefined) {
            obj.redemptionRecord = stakedym_1.RedemptionRecord.toJSON(message.redemptionRecord);
        }
        return obj;
    },
    create(base) {
        return exports.MsgOverwriteRedemptionRecord.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMsgOverwriteRedemptionRecord();
        message.creator = (_a = object.creator) !== null && _a !== void 0 ? _a : "";
        message.redemptionRecord = (object.redemptionRecord !== undefined && object.redemptionRecord !== null)
            ? stakedym_1.RedemptionRecord.fromPartial(object.redemptionRecord)
            : undefined;
        return message;
    },
};
function createBaseMsgOverwriteRedemptionRecordResponse() {
    return {};
}
exports.MsgOverwriteRedemptionRecordResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgOverwriteRedemptionRecordResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgOverwriteRedemptionRecordResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgOverwriteRedemptionRecordResponse();
        return message;
    },
};
function createBaseMsgSetOperatorAddress() {
    return { signer: "", operator: "" };
}
exports.MsgSetOperatorAddress = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.signer !== "") {
            writer.uint32(10).string(message.signer);
        }
        if (message.operator !== "") {
            writer.uint32(18).string(message.operator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOperatorAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.signer = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.operator = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
            operator: isSet(object.operator) ? globalThis.String(object.operator) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signer !== "") {
            obj.signer = message.signer;
        }
        if (message.operator !== "") {
            obj.operator = message.operator;
        }
        return obj;
    },
    create(base) {
        return exports.MsgSetOperatorAddress.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseMsgSetOperatorAddress();
        message.signer = (_a = object.signer) !== null && _a !== void 0 ? _a : "";
        message.operator = (_b = object.operator) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseMsgSetOperatorAddressResponse() {
    return {};
}
exports.MsgSetOperatorAddressResponse = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetOperatorAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.MsgSetOperatorAddressResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseMsgSetOperatorAddressResponse();
        return message;
    },
};
function longToString(long) {
    return long.toString();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=tx.js.map